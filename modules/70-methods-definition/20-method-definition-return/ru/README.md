
Методы, которые мы определяли в предыдущих уроках, заканчивали свою работу тем, что печатали на экран какие-то данные:

```cs
class App
{
    public static void Greeting()
    {
        Console.WriteLine("Winter is coming");
    }
}
```

Пользы от таких методов не очень много, так как результатом их работы невозможно воспользоваться внутри программы. Рассмотрим это на примере.

Возьмем задачу обработки электронной почты. Когда пользователь регистрируется на каком-то сайте, то он может ввести email любым способом:

* Добавив случайно пробелы в начале или в конце `_support@hexlet.io__`
* Использовав буквы в разном регистре `SUPPORT@hexlet.io`

Если мы сохраним его в таком виде в базу данных, то пользователь, скорее всего, не сможет войти на сайт, так как будет вбивать адрес без пробелов и используя другой регистр символов. Чтобы этого не произошло, email нужно подготовить к записи в базу, привести его к нижнему регистру и обрезать пробельные символы по краям строки. Вся задача решается в несколько строчек:

```cs
class App
{
    public static void Main(string[] args)
    {
        // В реальности email приходит из формы
        var email = "  SuppORT@hexlet.IO";
        // обрезаем пробельные символы
        var trimmedEmail = email.Trim();
        // приводим к нижнему регистру
        var preparedEmail = trimmedEmail.ToLower();
        Console.WriteLine(preparedEmail); // => "support@hexlet.io"
        // здесь будет запись в базу данных
    }
}
```

Этот код стал возможен только благодаря возврату значения. Методы `Trim()` и `ToLower()` ничего не печатают на экран (в консоль), они **возвращают** результат своей работы и поэтому мы можем записать его в переменные. Если бы они вместо этого печатали на экран, мы бы не могли присвоить результат их работы переменной. Как мы не можем сделать с определенным выше методом `Greeting()`:

```cs
// C# будет ругаться что `Greeting()` ничего не возвращает
// Код не заработает
var message = App.Greeting();
```

Изменим метод `Greeting()` таким образом, чтобы он начал возвращать данные, вместо их печати. Для этого нам понадобится выполнить две правки:

* Описать тип возвращаемых данных. В нашем случае это строка `string`
* Выполнить возврат вместо печати на экран

```cs
class App
{
    public static string Greeting()
    {
        return "Winter is coming!";
    }
}
```

Вместо `void` теперь написано `string`, потому что у метода есть возврат. Так мы указали C#, что результатом работы метода будет строка.

`return` – особая инструкция, которая берет выражение, записанное справа и отдает его наружу, тому коду, который вызвал метод. Как только C# натыкается на `return`, выполнение метода на этом завершается.

```cs
// Теперь этот код работает
var message = App.Greeting();
// Мы можем выполнить какие-то действия над результатом
Console.WriteLine(message.ToUpper()); // => "WINTER IS COMING!"
```

Любой код после `return` не выполняется:

```cs
class App
{
    public static string Greeting()
    {
        return "Winter is coming!";
        // Любой код ниже не выполнится никогда
        Console.WriteLine("Я никогда не выполнюсь");
    }
}
```

Даже если метод возвращает данные, это не ограничивает его в том, что он печатает. Кроме возврата данных мы можем и печатать:

```cs
class App
{
    public static string Greeting()
    {
        Console.WriteLine("Я появлюсь в консоли");
        return "Winter is coming!";
    }
}

// Где-то в другом методе
// И напечатает текст на экран и вернет значение
var value = App.Greeting();
```

Возвращать можно не только конкретное значение. Так как `return` работает с выражениями, то справа от него может появиться почти все что угодно. Здесь нужно руководствоваться принципами читаемости кода:

```cs
class App
{
    public static string Greeting()
    {
        var message = "Winter is coming!";
        return message;
    }
}
```

Здесь мы не возвращаем переменную, возвращается всегда значение, которое находится в этой переменной. Ниже пример с вычислениями:


```cs
class App
{
    public static long DoubleFive()
    {
        // или return 5 + 5;
        var result = 5 + 5;
        return result;
    }
}
```

В этом примере в определении метода использовался `long` так как возвращается целое число.

Вопрос на самопроверку. Что вернёт этот метод?

```cs
// Определение
class App
{
    public static int Run()
    {
        return 5;
        return 10;
    }
}

// Использование
App.Run(); // ?
```
